
void protocol_data_receive(uint8_t *data, uint16_t len)
{
    buf_put_data(parser.recursive_buffer_pointer,
                 PROTOCOL_RECURSIVE_BUFFER_SIZE,
                 parser.write_offset,
                 data,
                 len);
    parser.write_offset = (parser.write_offset + len) % PROTOCOL_RECURSIVE_BUFFER_SIZE;
}

uint16_t protocol_data_handler(void)
{
    uint8_t frame_data[PROTOCOL_FRAME_MAX_SIZE];
    uint16_t frame_len = 0;
    uint16_t cmd_type  = NULL_CMD;

    cmd_type = protocol_frame_parse(frame_data, &frame_len);
    return cmd_type;
}


/**
 * @brief find frame header in the buffer
 * @param  buf: pointer to the buffer
 * @param  buf_len: buffer length
 * @param  start: start index of the buffer
 * @param  target_len: target length of the frame(need to find)
 * @return int32_t: -1: not found, other: found index
 */
static int32_t find_frame_header(uint8_t *buf, uint16_t buf_len, uint16_t start, uint16_t target_len)
{
    uint16_t i = 0;
    for (i = 0; i < (target_len - 3); i++) {
        if (((buf[(start + i + 0) % buf_len] << 0) |
             (buf[(start + i + 1) % buf_len] << 8) |
             (buf[(start + i + 2) % buf_len] << 16) |
             (buf[(start + i + 3) % buf_len] << 24)) == PROTOCOL_FRAME_HEADER) {
            return ((start + i) % buf_len);
        }
    }
    return -1;
}

/**
 * @brief parse the frame
 * @param  data: frame data
 * @param  data_len: frame length
 * @return uint16_t: command value
 */
static uint16_t protocol_frame_parse(uint8_t *data, uint16_t *data_len)
{
    uint16_t cmd                     = NULL_CMD;
    protocol_frame_parsed_result.cmd = cmd;
    uint16_t unparsed_len            = 0;
    int32_t header_ofs               = -1;
    uint8_t checksum                 = 0;

    unparsed_len = get_unparsed_frame_len(parser.frame_len, PROTOCOL_RECURSIVE_BUFFER_SIZE, parser.read_offset, parser.write_offset);
    if (unparsed_len < PROTOCOL_FRAME_HEADER_SIZE) {
        return cmd;
    }

    // no frame header founded, continue found
    if (0 == parser.found_frame_head) {
        header_ofs = find_frame_header(parser.recursive_buffer_pointer,
                                       PROTOCOL_RECURSIVE_BUFFER_SIZE,
                                       parser.read_offset,
                                       unparsed_len);
        if (0 <= header_ofs) {
            // frame header founded
            parser.found_frame_head = 1;
            parser.read_offset      = header_ofs;

            // check if unparsed frame size >= ideal frame size
            if (get_unparsed_frame_len(parser.frame_len,
                                       PROTOCOL_RECURSIVE_BUFFER_SIZE,
                                       parser.read_offset,
                                       parser.write_offset) < PROTOCOL_FRAME_HEADER_SIZE) {
                return cmd;
            }
        } else {
            // no valid frame header in unparsed data, remove all data in this parse
            parser.read_offset = ((parser.read_offset + unparsed_len - 3) % PROTOCOL_RECURSIVE_BUFFER_SIZE);
            return cmd;
        }
    }

    // check frame length valid
    if (0 == parser.frame_len) {
        parser.frame_len = get_frame_len(parser.recursive_buffer_pointer, parser.read_offset);
        if (unparsed_len < parser.frame_len) {
            return cmd;
        }
    }

    // frame header valid, do checksum
    if ((parser.frame_len + parser.read_offset - PROTOCOL_FRAME_CHECKSUM_SIZE) > PROTOCOL_RECURSIVE_BUFFER_SIZE) {
        checksum = calculate_checksum(checksum, parser.recursive_buffer_pointer + parser.read_offset,
                                      PROTOCOL_RECURSIVE_BUFFER_SIZE - parser.read_offset);
        checksum = calculate_checksum(checksum, parser.recursive_buffer_pointer, parser.frame_len - PROTOCOL_FRAME_CHECKSUM_SIZE + parser.read_offset - PROTOCOL_RECURSIVE_BUFFER_SIZE);
    } else {
        checksum = calculate_checksum(checksum, parser.recursive_buffer_pointer + parser.read_offset, parser.frame_len - PROTOCOL_FRAME_CHECKSUM_SIZE);
    }

    uint8_t tmp_checksum = 0;
    tmp_checksum         = get_frame_checksum(parser.recursive_buffer_pointer,
                                              parser.read_offset,
                                              parser.frame_len);
    if (checksum == tmp_checksum) {
        // all data valid
        if ((parser.read_offset + parser.frame_len) > PROTOCOL_RECURSIVE_BUFFER_SIZE) {
            uint16_t data_len_part = PROTOCOL_RECURSIVE_BUFFER_SIZE - parser.read_offset;
            memcpy(data, parser.recursive_buffer_pointer + parser.read_offset, data_len_part);
            memcpy(data + data_len_part, parser.recursive_buffer_pointer, parser.frame_len - data_len_part);
        } else {
            memcpy(data, parser.recursive_buffer_pointer + parser.read_offset, parser.frame_len);
        }
        *data_len = parser.frame_len;
        cmd       = get_frame_cmd(data, 0);
        deserialize_frame_data_from_dest(data,
                                         &protocol_frame_parsed_result);
        parser.read_offset = (parser.read_offset + parser.frame_len) % PROTOCOL_RECURSIVE_BUFFER_SIZE;
    } else {
        // check error, update read_offset
        parser.read_offset = (parser.read_offset + 1) % PROTOCOL_RECURSIVE_BUFFER_SIZE;
    }
    parser.frame_len        = 0;
    parser.found_frame_head = 0;

    return cmd;
}

/**
 * @brief Get the unparsed frame length
 * @param  frame_len: ideal frame length
 * @param  buff_len: ring buffer length
 * @param  start: start parse index in ring buffer
 * @param  end: end parse index in ring buffer
 * @return uint16_t: unparsed frame length, 0: error
 */
static uint16_t get_unparsed_frame_len(uint16_t frame_len, uint16_t buff_len, uint16_t start, uint16_t end)
{
    uint16_t unparsed_len = 0;
    if (start <= end) {
        unparsed_len = end - start;
    } else {
        unparsed_len = buff_len - start + end;
    }

    if (frame_len > unparsed_len) {
        return 0;
    } else {
        return unparsed_len;
    }
}

/**
 * @brief write the data into the ring buffer
 * @param  buf: ring buffer pointer
 * @param  ring_buf_len: ring buffer max length
 * @param  w_ofs: write offset
 * @param  data: target data
 * @param  data_len: data length
 */
static void buf_put_data(uint8_t *buf, uint16_t ring_buf_len, uint16_t w_ofs,
                         uint8_t *data, uint16_t data_len)
{
    if ((w_ofs + data_len) > ring_buf_len) {
        uint16_t data_len_part = ring_buf_len - w_ofs;
        memcpy(buf + w_ofs, data, data_len_part);
        memcpy(buf, data + data_len_part, data_len - data_len_part);
    } else
        memcpy(buf + w_ofs, data, data_len);
}

/**
 * @brief swap cmd header in data array
 * @param  cmd: data array
 */
static void swap_cmd_header(uint8_t *cmd)
{
    uint8_t tmp               = 0;
    tmp                       = cmd[FRAME_INDEX_HEAD + 0];
    cmd[FRAME_INDEX_HEAD + 0] = cmd[FRAME_INDEX_HEAD + 3];
    cmd[FRAME_INDEX_HEAD + 3] = tmp;

    tmp                       = cmd[FRAME_INDEX_HEAD + 2];
    cmd[FRAME_INDEX_HEAD + 2] = cmd[FRAME_INDEX_HEAD + 1];
    cmd[FRAME_INDEX_HEAD + 1] = tmp;
}

/**
 * @brief swap cmd length in data array
 * @param  cmd: data array
 */
static void swap_cmd_length(uint8_t *cmd)
{
    uint8_t tmp              = 0;
    tmp                      = cmd[FRAME_INDEX_LEN + 0];
    cmd[FRAME_INDEX_LEN + 0] = cmd[FRAME_INDEX_LEN + 1];
    cmd[FRAME_INDEX_LEN + 1] = tmp;
}

/**
 * @brief swap cmd type in data array
 * @param  cmd: data array
 */
static void swap_cmd_type(uint8_t *cmd)
{
    uint8_t tmp              = 0;
    tmp                      = cmd[FRAME_INDEX_CMD + 0];
    cmd[FRAME_INDEX_CMD + 0] = cmd[FRAME_INDEX_CMD + 1];
    cmd[FRAME_INDEX_CMD + 1] = tmp;
}